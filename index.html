<!doctype html>
<html lang="en" data-theme="light">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cade’s Tools</title>
<meta name="description" content="Cade’s link directory" />
<meta name="color-scheme" content="light dark" />

<!-- IBM Plex Sans everywhere -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">

<style>
  :root{
    --radius: 14px;
    --shadow: 0 1px 1px rgba(0,0,0,.03), 0 10px 25px rgba(0,0,0,.06);
    --gap: clamp(.9rem, 2.5vw, 1.25rem);
    --maxw: 1120px;
    
    user-select: none;

    /* theme defaults (light) */
    --bg: #fafaf7;
    --bg-elev:#ffffff;
    --ink:#161716;
    --muted:#6e6e6e;
    --ring:#0f766e; /* teal */
    --ring-light: color-mix(in srgb, var(--ring) 55%, white);
    --card:#ffffff;
    --border: rgba(20,20,20,.08);
  }
  [data-theme="dark"]{
    --bg: #0f0f0e;
    --bg-elev:#121212;
    --ink:#f6f6f4;
    --muted:#a1a1a1;
    --ring:#2dd4bf;
    --ring-light: color-mix(in srgb, var(--ring) 55%, white);
    --card:#141414;
    --border: rgba(246,246,244,.09);
    --shadow: 0 1px 1px rgba(0,0,0,.25), 0 10px 25px rgba(0,0,0,.35);
  }
  
  #themeBtn {
	color: var(--ink);
  }
  
  mark {
	background-color: #b2d8d8;
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font: 15px/1.45 "IBM Plex Sans", ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    color:var(--ink);
    background: var(--bg);
  }

  /* Background canvas behind everything */
  #bg {
    position:fixed; inset:0; z-index:0; display:block; width:100%; height:100%;
    pointer-events:none;
  }
  
  .hit {
	display: flex;
	flex-direction: column;
	justify-content: space-between;
	height: 100%;
	min-height: 75px;
	cursor: pointer;
  }
  
  .hit card-footer {
	
  }

  .wrap{max-width:var(--maxw); margin:auto; padding:24px clamp(14px,3vw,24px) 56px; position:relative; z-index:1}
  header{display:grid; gap:.4rem; justify-items:center; text-align:center; margin:18px 0 10px}

  /* Click-to-copy title */
  .title-copy {
    margin:0;
    font-weight:800;
	text-transform:uppercase;
	font-size:clamp(18px, 2vw, 22px);
    cursor:pointer; user-select:none;
    color: var(--ring);
	letter-spacing: 0.2rem;
    transition: transform .08s ease, color .15s ease, text-shadow .15s ease;
    position: relative;
	font-variant: small-caps;
  }
  .title-copy:hover {
    color: var(--ring-light);
    text-shadow: 0 0 0 rgba(0,0,0,0);
  }
  .title-copy:active {
    transform: scale(0.98);
  }

  .sub{color:var(--muted); font-weight:500; font-size:.95rem; margin-top:-0.8rem; user-select:text;}

  .toprow{display:flex; gap:.6rem; align-items:center; margin-top:.4rem}
  .icons{display:flex; gap:.6rem}
  .icon, .toggle{
    display:inline-flex; align-items:center; justify-content:center; width:36px; height:36px;
    border-radius:999px; border:1px solid var(--border); background:var(--bg-elev);
    transition: transform .15s ease, border-color .15s ease, box-shadow .15s ease, background-color .15s ease;
  }
  .icon:hover, .toggle:hover{
    transform:translateY(-1px);
    border-color: color-mix(in srgb, var(--ring) 35%, var(--border));
    box-shadow: 0 0 0 2px color-mix(in srgb, var(--ring) 12%, transparent);
    background: color-mix(in srgb, var(--bg-elev) 80%, var(--ring) 20%);
  }
  .icon svg{ width:18px; height:18px; color:var(--ink); opacity:.85 }
  .toggle{ cursor:pointer; gap:.25rem; padding:0 .35rem; font-size:0; /* icon-only */ }

  /* Floating search (no background strip) */
  .searchbar{
    position:sticky; top:0; z-index:2; padding:12px 0; margin:22px 0 20px;
  }
  .search{
    width:100%; max-width:560px; margin:auto; display:flex; gap:.5rem; align-items:center;
    background:var(--bg-elev); border:1px solid var(--border); border-radius:999px; padding:.65rem .9rem;
    box-shadow: var(--shadow);
  }
  .search input{
    flex:1; border:0; outline:0; background:transparent; color:var(--ink);
    font-size:1rem; min-width:120px; font-family: "IBM Plex Sans", sans-serif;
  }
  .kbd{
    font-variant-numeric: tabular-nums; border:1px solid var(--border); border-radius:6px; padding:.15rem .4rem; color:var(--muted);
  }
  .hint{color:var(--muted); font-size:.85rem}

  .grid{
    display:grid; gap:var(--gap);
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    align-items:stretch;
  }
  .card{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:var(--radius);
    padding:18px 16px;
    box-shadow: var(--shadow);
    transition: transform .15s ease, border-color .15s ease, box-shadow .15s ease;
    display:flex; flex-direction:column; gap:.35rem;
	height: 100%;
	display: flex;
	justify-content:space-between;
  }
  .card:hover{ transform:translateY(-2px); border-color: color-mix(in srgb, var(--ring) 35%, var(--border)); }
  .card:focus-visible{ outline:2px solid var(--ring); outline-offset:2px }
  .card a{ color:inherit; text-decoration:none }
  .title{font-weight:700; font-family: "IBM Plex Sans", sans-serif;}
  .desc{color:var(--muted); font-size:.8rem}
  .meta{
    margin-top:0.25rem;
    display:flex;
     justify-content:flex-end;
     align-items:center;
     gap: 0.1rem;
     }
  .badge{
    border:1px solid var(--border);
    border-radius:999px;
    padding:.15rem .5rem;
    color:var(--muted);
    font-size:.7rem;
    font-family: "IBM Plex Sans", sans-serif;
  }
  footer {
  margin-top:36px;
  color:var(--muted);
  font-size:.9rem;
  text-align:center;
  width: 100%;
  display: flex;
  justify-content: center;
  }
  
 .footer-text{
  backdrop-filter: blur(80px);
  -webkit-backdrop-filter:blur(80px);
  width: fit-content;
  padding: 0 20px;
  }

  /* selection colors */
  ::selection { background-color:#b2d8d8; color:#006666; }
  ::-moz-selection { background-color:#b2d8d8; color:#006666; }

  .ctrl {
    position: fixed; right: 14px; bottom: 14px; z-index: 3;
    background: var(--bg-elev); border:1px solid var(--border);
    border-radius: 12px; padding: 10px; box-shadow: var(--shadow);
    display: flex; align-items: center; gap: 10px; font-size: 12px; color: var(--muted);
    flex-wrap: wrap;
    
  }
  .ctrl-hint {
    position: fixed; right: 14px; bottom: 14px; z-index: 3;
    background: var(--bg-elev);
    display: flex; align-items: center; gap: 10px; font-size: 12px; color: var(--muted);
    flex-wrap: wrap;
  }
  .ctrl label { display:flex; align-items:center; gap:6px; white-space: nowrap; }
  .ctrl input[type="range"]{ width: 110px; }
  .ctrl input[type="color"]{ width: 28px; height: 28px; padding:0; border: none; background: none; }
  
  .hidden {
   display: none;
   }
</style>
</head>
<body>
  <canvas id="bg" aria-hidden="true"></canvas>

  <div class="wrap">
    <header aria-label="Header">
      <h1 class="title-copy" id="copyTitle" title="Click to copy URL">Cade’s Tools</h1>
      <div class="sub">Various tools for various things</div>
      <div class="toprow">
        <nav class="icons" aria-label="Profiles">
          <a class="icon" href="https://www.linkedin.com/in/cadezawacki" target="_blank" rel="noopener" aria-label="LinkedIn">
            <svg viewBox="0 0 24 24" role="img" aria-hidden="true"><path fill="currentColor" d="M4.98 3.5a2.5 2.5 0 1 1 .02 5.001A2.5 2.5 0 0 1 4.98 3.5M3 8.982h3.96V21H3zM9.69 8.982H13.5v1.65h.05c.53-.95 1.83-1.95 3.77-1.95 4.03 0 4.78 2.54 4.78 5.85V21H18.1v-4.78c0-1.14-.02-2.6-1.58-2.6-1.58 0-1.82 1.23-1.82 2.5V21H9.69z"/></svg>
          </a>
          <a class="icon" href="https://github.com/cadezawacki" target="_blank" rel="noopener" aria-label="GitHub">
            <svg viewBox="0 0 24 24" role="img" aria-hidden="true"><path fill="currentColor" d="M12 2a10 10 0 0 0-3.16 19.49c.5.09.68-.22.68-.48v-1.7c-2.77.61-3.36-1.19-3.36-1.19-.46-1.16-1.12-1.47-1.12-1.47-.92-.63.07-.62.07-.62 1.02.07 1.56 1.05 1.56 1.05.9 1.54 2.36 1.1 2.94.84.09-.66.35-1.1.63-1.35-2.21-.25-4.54-1.11-4.54-4.95 0-1.09.39-1.99 1.03-2.69-.1-.25-.45-1.26.1-2.62 0 0 .84-.27 2.75 1.03A9.57 9.57 0 0 1 12 6.8c.85 0 1.71.11 2.51.32 1.9-1.3 2.74-1.03 2.74-1.03.56 1.36.21 2.37.1 2.62.64.7 1.03 1.6 1.03 2.69 0 3.85-2.33 4.69-4.55 4.94.36.31.68.92.68 1.86v2.76c0 .27.18.58.69.48A10 10 0 0 0 12 2z"/></svg>
          </a>
          <a class="icon" href="https://www.cadesmugs.com" target="_blank" rel="noopener" aria-label="Cade’s Mugs">
            <svg viewBox="0 0 24 24" role="img" aria-hidden="true"><path fill="currentColor" d="M4 4h11a2 2 0 0 1 2 2v1h1.5A3.5 3.5 0 0 1 22 10.5v1A3.5 3.5 0 0 1 18.5 15H17a6 6 0 0 1-6 6H8a6 6 0 0 1-6-6V6a2 2 0 0 1 2-2Zm13 9h1.5A1.5 1.5 0 0 0 20.5 11v-1A1.5 1.5 0 0 0 18.5 8H17z"/></svg>
          </a>
        </nav>
        <button class="toggle" id="themeBtn" type="button" aria-label="Toggle theme">
          <!-- icon injected via JS -->
        </button>
      </div>
    </header>

    <div class="searchbar" role="search">
      <div class="search" aria-label="Search tools">
        <input id="q" type="search" placeholder="Search tools (press / to focus)" autocomplete="off" inputmode="search" />
        <span class="hint"><span class="kbd">↑</span><span class="kbd">↓</span><span class="kbd">Enter</span></span>
      </div>
    </div>
    
    <div class='ctrl-hint'><span class='kbd'>ctrl+k</span></div>
    <div class="ctrl hidden" id="ctrl">
      <label title="Distorted region color">
        <input id="distortColor" type="color" value="#0f766e">
      </label>
      <label title="Opacity multiplier in distorted region">
        Opacity <input id="distortAlpha" type="range" min="0.2" max="10" step="0.05" value="3">
      </label>
      <label title="Character change probability multiplier">
        Prob <input id="distortProb" type="range" min="0" max="3" step="0.05" value="1">
      </label>
      <label title="Base mouse distortion radius (px)">
        Radius <input id="distortRadius" type="range" min="10" max="300" step="1" value="80">
      </label>
      <label title="Mouse-down radius multiplier">
        Down × <input id="downRadiusMult" type="range" min="0.5" max="5" step="0.05" value="1.6">
      </label>
      <!-- NEW: Fish-eye intensity on mouse down -->
      <label title="Fish-eye intensity when mouse is down">
        Fish-eye <input id="fishEye" type="range" min="0" max="3" step="0.05" value="0.2">
      </label>
    </div>

        <main>
          <section class="grid" id="grid" aria-label="Tool links"></section>
          <footer><div class="footer-text">Made by Cade Zawacki • <span id="count"></span></div></footer>
        </main>
      </div>

<script>
/* ===== Worker refs ===== */
let worker = null, workerReady = false;
function postToWorker(msg){ if(workerReady && worker) worker.postMessage(msg); }

const $color = document.getElementById('distortColor');
const $alpha = document.getElementById('distortAlpha');
const $prob  = document.getElementById('distortProb');
const $radius = document.getElementById('distortRadius');       
const $downMult = document.getElementById('downRadiusMult');     
const $fishEye = document.getElementById('fishEye');             

function sendDistortParams(){
  postToWorker({
    type: 'distortParams',
    color: $color.value,                     // hex color for distorted region
    alphaFactor: parseFloat($alpha.value),   // multiply local opacity
    probFactor:  parseFloat($prob.value),    // multiply char-change probability
    baseRadius:  parseFloat($radius.value),  // NEW base mouse influence radius (px)
    downRadiusMult: parseFloat($downMult.value), // NEW radius multiplier when mouse is down
    fishEyeIntensity: parseFloat($fishEye.value) // NEW fish-eye intensity on press
  });
}

/* ===== Theme (2-state) with SVG icons ===== */
const DARK_SVG  = `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M12 17q-2.075 0-3.537-1.463T7 12t1.463-3.537T12 7t3.538 1.463T17 12t-1.463 3.538T12 17M2 13q-.425 0-.712-.288T1 12t.288-.712T2 11h2q.425 0 .713.288T5 12t-.288.713T4 13zm18 0q-.425 0-.712-.288T19 12t.288-.712T20 11h2q.425 0 .713.288T23 12t-.288.713T22 13zm-8-8q-.425 0-.712-.288T11 4V2q0-.425.288-.712T12 1t.713.288T13 2v2q0 .425-.288.713T12 5m0 18q-.425 0-.712-.288T11 22v-2q0-.425.288-.712T12 19t.713.288T13 20v2q0 .425-.288.713T12 23M5.65 7.05L4.575 6q-.3-.275-.288-.7t.288-.725q.3-.3.725-.3t.7.3L7.05 5.65q.275.3.275.7t-.275.7t-.687.288t-.713-.288M18 19.425l-1.05-1.075q-.275-.3-.275-.712t.275-.688q.275-.3.688-.287t.712.287L19.425 18q.3.275.288.7t-.288.725q-.3.3-.725.3t-.7-.3M16.95 7.05q-.3-.275-.288-.687t.288-.713L18 4.575q.275-.3.7-.288t.725.288q.3.3.3.725t-.3.7L18.35 7.05q-.3.275-.7.275t-.7-.275M4.575 19.425q-.3-.3-.3-.725t.3-.7l1.075-1.05q.3-.275.712-.275t.688.275q.3.275.288.688t-.288.712L6 19.425q-.275.3-.7.288t-.725-.288"/></svg>`;

const LIGHT_SVG  = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path fill="currentColor" d="m14.712 7.596l-2.289-2.288l2.289-2.289L17 5.308zm5 3l-1.289-1.288l1.289-1.289L21 9.308zM12.075 21q-1.888 0-3.543-.713T5.64 18.336t-1.951-2.893t-.714-3.543q0-2.92 1.68-5.265t4.436-3.27q-.104 2.34.717 4.501q.82 2.161 2.48 3.82q1.66 1.66 3.82 2.481t4.502.717q-.92 2.754-3.268 4.435T12.075 21"/></svg>`;

const root = document.documentElement;
const themeBtn = document.getElementById('themeBtn');
const THEME_KEY = 'theme2';
function setTheme(next){
  root.setAttribute('data-theme', next);
  localStorage.setItem(THEME_KEY, next);
  themeBtn.innerHTML = next==='dark' ? LIGHT_SVG : DARK_SVG;
  postToWorker({ type:'toggleDark', darkMode: next==='dark' });
}
(function(){
  const initial = localStorage.getItem(THEME_KEY) === 'dark' ? 'dark' : 'light';
  setTheme(initial);
})();
themeBtn.addEventListener('click',()=>{
  setTheme(root.getAttribute('data-theme')==='dark' ? 'light' : 'dark');
});

/* ===== Click-to-copy on title ===== */
const copyTitle = document.getElementById('copyTitle');
copyTitle.addEventListener('click', async ()=>{
  try{
    await navigator.clipboard.writeText(location.href);
    copyTitle.textContent = '-- COPIED --';
	copyTitle.classList.add('copied');
    setTimeout(()=>{
		copyTitle.textContent = "Cade's Tools";
		copyTitle.classList.remove('copied')
	}, 1200);
  }catch(e){
    // fallback
    const sel = window.getSelection(); const r = document.createRange();
    r.selectNodeContents(copyTitle); sel.removeAllRanges(); sel.addRange(r);
  }
});

/* ================= DATA / UI ================= */
const TOOLS = [
  { title: "Advanced File Stringify-er", href: "advFile.html", desc: "Convert multiple files to a single string locally — then unparse back into files.", badges:['files', 'transfer']},
  { title: "Color Manager", href: "color.html", desc: "Convert between color formats and adjust colors.", badges:['color']},
  { title: "Color Manager V2", href: "color_v2.html", desc: "Beta version with tweaks and experiments.", badges:['color']},
  { title: "File Stringify-er", href: "files.html", desc: "Locally combine multiple files into a single string and copy.", badges:['files', 'transfer']},
  { title: "Minimal Music Player", href: "music.html", desc: "Super minimal media streamer.", badges:['music']},
  { title: "Stun", href: "stun.html", desc: "A sync utility.", badges:['???']},
];

const qs = (s, el=document)=>el.querySelector(s);
const grid = qs('#grid');
const input = qs('#q');
const countEl = qs('#count');
const ctrl = qs('#ctrl');

TOOLS.sort((a,b)=>a.title.localeCompare(b.title, undefined, {sensitivity:'base'}));
function card(t, i){
  const el = document.createElement('article');
  el.className = 'card';
  el.tabIndex = 0;
  el.dataset.index = i;
  
  let badges = ``;
  if (t?.badges) {
    const b = Array.from(t.badges);
    b.forEach(badge=> {
      badges += `<span class="badge">${badge}</span>`
    });
  } else {
    badges = `<span class="badge">tool</span>`;
  }
  
  el.innerHTML = `
    <a href="${t.href}" class="hit" aria-label="${t.title}">
      <div class="card-text">
		<div class="title">${t.title}</div>
		<div class="desc">${t.desc}</div>
	  </div>
	  <div class="card-footer">
		<div class="meta">
      ${badges}
    </div>
	  </div>
    </a>`;
  
  return el;
}
const nodes = TOOLS.map(card);
nodes.forEach(n=>grid.appendChild(n));
function updateCount(visible = TOOLS.length){
  if (visible !== TOOLS.length) {
	const total = TOOLS.length;
	countEl.textContent = `${visible} out of ${total} tool${total===1?'':'s'}`;
  } else {
	countEl.textContent = `${visible} tool${visible===1?'':'s'}`;
  }
}
updateCount();

/* Search + shareable URL */
const params = new URLSearchParams(location.search);
if(params.get('q')) input.value = params.get('q');
filter(input.value);
function filter(termRaw){
  const term = (termRaw||'').trim().toLowerCase();
  const re = term ? new RegExp(term.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'), 'i') : null;
  let visible = 0;
  nodes.forEach(n=>{
    const t = n.querySelector('.title').textContent;
    const d = n.querySelector('.desc').textContent;
    const match = !term || re.test(t) || re.test(d);
    n.style.display = match ? '' : 'none';
    if(match) visible++;
    n.querySelector('.title').innerHTML = re ? t.replace(re, m=>`<mark>${m}</mark>`) : t;
    n.querySelector('.desc').innerHTML = re ? d.replace(re, m=>`<mark>${m}</mark>`) : d;
  });
  updateCount(visible);
  const url = new URL(location);
  if(term) url.searchParams.set('q', term); else url.searchParams.delete('q');
  history.replaceState({}, '', url);
}
input.addEventListener('input', e=>filter(e.target.value));

/* 4-direction grid keyboard nav */
function visibleCards(){ return nodes.filter(n=>n.style.display!=='none'); }
function center(el){ const r = el.getBoundingClientRect(); return { x: r.left + r.width/2, y: r.top + r.height/2 }; }
function moveFocus(dir){
  const vc = visibleCards(); if(!vc.length) return;
  const active = document.activeElement?.closest('.card');
  const cur = active && vc.includes(active) ? active : vc[0];
  const c0 = center(cur);
  const eps = 4;
  const candidates = vc.filter(el=>el!==cur).map(el=>{
    const c = center(el);
    return { el, c, dx: c.x - c0.x, dy: c.y - c0.y };
  }).filter(({dx,dy})=>{
    if(dir==='right') return dx > eps;
    if(dir==='left')  return dx < -eps;
    if(dir==='down')  return dy > eps;
    if(dir==='up')    return dy < -eps;
  });
  if(!candidates.length) return;
  let best = candidates[0], bestScore = Infinity;
  for(const cand of candidates){
    const {dx,dy} = cand;
    let primary = (dir==='left'||dir==='right') ? Math.abs(dx) : Math.abs(dy);
    let ortho   = (dir==='left'||dir==='right') ? Math.abs(dy) : Math.abs(dx);
    const score = primary*primary + ortho*ortho*0.6;
    if(score < bestScore){ bestScore = score; best = cand; }
  }
  best.el.focus({preventScroll:false});
}


window.addEventListener('keydown', (e)=>{
  if(e.key === '/' && document.activeElement !== input){
    e.preventDefault();
    input.focus();
    input.select();
    return;
  }
  
  if(e.key === 'f' && e.ctrlKey && document.activeElement !== input){
    e.preventDefault();
    input.focus();
    input.select();
    return;
  }
  
  if(e.key === 'k' && e.ctrlKey && document.activeElement !== input){
    e.preventDefault();
    ctrl.classList.toggle('hidden')
    return;
  }
  
  if(e.key === 'l' && e.ctrlKey){
	e.preventDefault();
	if ( document.activeElement !== input ) {
		input.focus();
		input.select();
	}
	input.value = '';
	filter('');
	return;
  }
  if(e.key === 'Enter' && document.activeElement?.classList.contains('card')){ document.activeElement.querySelector('a.hit').click(); return; }
  if(e.key === 'Escape'){ input.blur(); return; }
  if(['ArrowRight','ArrowLeft','ArrowDown','ArrowUp'].includes(e.key)){ e.preventDefault(); moveFocus(e.key.replace('Arrow','').toLowerCase()); }
});

/* ================= MATRIX BACKGROUND (Worker) ================= */
  
const canvas = document.getElementById('bg');

(function initBG(){
  if(!('OffscreenCanvas' in window)) return;  // graceful fallback

  const offscreen = canvas.transferControlToOffscreen();
  const workerCode = `
    let canvas, ctx, width=0, height=0, dpr=1, darkMode=false;

    /* Tweakables (many are overridden by main thread controls) */
    const cellW = 12, cellH = 14;     // grid cell size
    const jitter = 6;                  // px jitter per cell
    let baseRadius = 40;               // px influence (from UI)
    let downRadiusMult = 1.6;          // multiplier when mouse is down (from UI)
    let fishEyeIntensity = 0.3;        // intensity (0..3) applied primarily on press

    const activityWindow = 140;        // ms active after move
    const idlePulseEvery = 900;        // ms soft refresh
    const charChangeProb = 0.05;

    let isDown = false;
    let lastDownT = 0;
    const downDecayMs = 320;           // how long the press shock decays

    let distortColor = '#0f766e';  // hex/string
    let distortAlphaFactor = 2.0;  // multiplies opacity inside ripple
    let distortProbFactor  = 1.0;  // multiplies char-change probability

    // Base alpha per theme; we'll multiply by a vertical fade
    const baseAlphaLight = 0.10, baseAlphaDark = 0.125;
    const topFade = 0.15;   // less opacity near top
    const bottomBoost = 1.0; // full at bottom

    /* Unicode pool like your matrix */
    const unicodeChars = (() => {
      const chars = [];
      const ranges = [
        { from: 0x0021, to: 0x007E },    // Basic Latin punctuation/symbols
        { from: 0x00A1, to: 0x00FF },    // Latin-1 Supplement
        { from: 0x1D00, to: 0x1D7F },    // IPA Extensions
        { from: 0x20A0, to: 0x20BF },    // Currency Symbols
      ];
      ranges.forEach(r => { for (let i=r.from;i<=r.to;i++) chars.push(String.fromCodePoint(i)); });
      return chars;
    })();
    function randomChar(){ return unicodeChars[(Math.random()*unicodeChars.length)|0]; }

    /* Grid state */
    let cols=0, rows=0, grid=[];
    const mouse = { x:-1e6, y:-1e6, outside:true };
    let lastActivity = 0;
    let animating = true;

    function hash(ix,iy,s){
      let h = (ix*374761393) ^ (iy*668265263) ^ ((s*2147483647)|0);
      h = (h ^ (h>>>13)) >>> 0;
      h = Math.imul(h, 1274126177);
      h = (h ^ (h>>>16)) >>> 0;
      return h / 4294967295;
    }

    function initGrid(){
      cols = Math.ceil(width / cellW);
      rows = Math.ceil(height / cellH);
      grid.length = 0;
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const bx = c*cellW + cellW/2;
          const by = r*cellH + cellH/2;
          const jx = (hash(c,r,1)*2-1)*jitter;
          const jy = (hash(c,r,2)*2-1)*jitter;
          grid.push({ bx, by, jx, jy, char: randomChar() });
        }
      }
    }

    function resize(w,h,dp){
      width=w; height=h; dpr=dp||1;
      canvas.width = width * dpr;
      canvas.height= height * dpr;
      ctx.resetTransform(); ctx.scale(dpr,dpr);
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font = (cellH*0.9)+'px "IBM Plex Sans", monospace';
      initGrid();
    }

    function draw(){
      const now = performance.now();
      const recent = (now - lastActivity) < activityWindow;
      const needsIdle = (now - lastActivity) > idlePulseEvery && !mouse.outside;
      if(!recent && !needsIdle){ animating = false; return; }

      // Theme bg
      ctx.fillStyle = darkMode ? '#0f0f0e' : '#fafaf7';
      ctx.fillRect(0,0,width,height);

      const baseAlpha = darkMode ? baseAlphaDark : baseAlphaLight;
      const textColor = darkMode ? 'rgb(246,246,244)' : 'rgb(22,23,22)';
      ctx.fillStyle = textColor;
      
      // Down boost: 1 during press, decays after
      let downBoost = 0.0;
      if(isDown) downBoost = 1.0;
      else if (lastDownT > 0) {
        const dt = now - lastDownT;
        if (dt < downDecayMs) downBoost = Math.exp(-dt / downDecayMs);
      }

      const effRadius = mouse.outside ? 0 : baseRadius * (1 + downBoost * (downRadiusMult - 1));

      for(let i=0;i<grid.length;i++){
        const g = grid[i];
        const baseX = g.bx + g.jx, baseY = g.by + g.jy;

        const dx0 = baseX - mouse.x, dy0 = baseY - mouse.y;
        const dist0 = Math.hypot(dx0,dy0);
        const inside = effRadius>0 && dist0 < effRadius;

        let x = baseX, y = baseY;
        let localScale = 1.0;

        if(inside){
          // falloff 0..1 from edge->center
          const t = 1 - dist0/effRadius;
          const t2 = t*t;

          // Position "push" — stronger when pressed, scaled by fishEyeIntensity
          const pushBase = 36; // baseline push magnitude
          const push = pushBase * (1 + 1.2*fishEyeIntensity*downBoost) * t2;
          const inv = dist0 || 1;
          x += (dx0/inv) * push;
          y += (dy0/inv) * push;

          // Fish-eye SCALE (size) — primarily on press
          localScale = 1 + (1.5 * fishEyeIntensity * downBoost) * t2;

          // higher chance to morph characters when distorted
          const probBoost = (1 + 0.6*downBoost);
          if(Math.random() < charChangeProb * distortProbFactor * probBoost){
            g.char = unicodeChars[(Math.random()*unicodeChars.length)|0];
          }
        }

        // vertical fade factor (0..1) from top->bottom
        const vfade = topFade + (bottomBoost - topFade) * (g.by / Math.max(1,height));
        const localAlpha = baseAlpha * vfade * (inside ? distortAlphaFactor : 1);

        // draw (optionally tinted) with scaling about the glyph center
        const drawTinted = inside;
        const alphaClamped = Math.max(0, Math.min(1, localAlpha));

        if(drawTinted){
          ctx.fillStyle = distortColor;
        }else{
          ctx.fillStyle = textColor;
        }

        if(localScale !== 1){
          ctx.save();
          ctx.translate(g.bx, g.by);
          ctx.scale(localScale, localScale);
          ctx.globalAlpha = alphaClamped;
          ctx.fillText(g.char, 0, 0);
          ctx.globalAlpha = 1;
          ctx.restore();
        }else{
          ctx.globalAlpha = alphaClamped;
          ctx.fillText(g.char, g.bx, g.by);
          ctx.globalAlpha = 1;
        }

        // restore color for next glyph
        if(drawTinted){
          ctx.fillStyle = textColor;
        }
      }

      requestAnimationFrame(draw);
    }

    onmessage = (e)=>{
      const d = e.data;
      if(d.type==='init'){
        canvas = d.canvas;
        ctx = canvas.getContext('2d');
        resize(d.width, d.height, d.dpr);
        darkMode = d.dark;
        lastActivity = performance.now();
        animating = true;
        requestAnimationFrame(draw);
      } else if(d.type==='resize'){
        resize(d.width, d.height, d.dpr);
        lastActivity = performance.now();
        if(!animating){ animating=true; requestAnimationFrame(draw); }
      } else if(d.type==='mousemove'){
        mouse.x=d.x; mouse.y=d.y; mouse.outside=false;
        lastActivity = performance.now();
        if(!animating){ animating=true; requestAnimationFrame(draw); }
      } else if(d.type==='mouseleave'){
        mouse.outside=true;
        lastActivity = performance.now();
        if(!animating){ animating=true; requestAnimationFrame(draw); }
      } else if(d.type==='toggleDark'){
        darkMode = d.darkMode;
        lastActivity = performance.now();
        if(!animating){ animating=true; requestAnimationFrame(draw); }
      } else if(d.type==='mousedown'){
        isDown = true;
        lastActivity = performance.now();
        lastDownT = lastActivity;
        if(!animating){ animating=true; requestAnimationFrame(draw); }
      } else if(d.type==='mouseup'){
        isDown = false;
        lastActivity = performance.now();
        if(!animating){ animating=true; requestAnimationFrame(draw); }
      } else if(d.type==='distortParams'){
        if (typeof d.color === 'string') distortColor = d.color;
        if (typeof d.alphaFactor === 'number') distortAlphaFactor = Math.max(0, d.alphaFactor);
        if (typeof d.probFactor === 'number')  distortProbFactor  = Math.max(0, d.probFactor);
        if (typeof d.baseRadius === 'number')  baseRadius = Math.max(0, d.baseRadius|0);
        if (typeof d.downRadiusMult === 'number') downRadiusMult = Math.max(0, d.downRadiusMult);
        if (typeof d.fishEyeIntensity === 'number') fishEyeIntensity = Math.max(0, d.fishEyeIntensity);
        lastActivity = performance.now();
        if(!animating){ animating=true; requestAnimationFrame(draw); }
      }
    };
  `;
  const blob = new Blob([workerCode], { type:'application/javascript' });
  const url = URL.createObjectURL(blob);
  worker = new Worker(url);

  worker.postMessage({
    type:'init',
    canvas: offscreen,
    width: window.innerWidth,
    height: window.innerHeight,
    dpr: window.devicePixelRatio || 1,
    dark: root.getAttribute('data-theme')==='dark'
  }, [offscreen]);
  workerReady = true;

  // Forward events to worker
  window.addEventListener('resize', ()=>{
    postToWorker({ type:'resize', width: innerWidth, height: innerHeight, dpr: devicePixelRatio||1 });
  });
  window.addEventListener('mousemove', (e)=>{
    postToWorker({ type:'mousemove', x: e.clientX, y: e.clientY });
  });
  window.addEventListener('mouseleave', ()=>{
    postToWorker({ type:'mouseleave' });
  });
  window.addEventListener('mousedown', () => {
    postToWorker({ type: 'mousedown' });
  });
  window.addEventListener('mouseup', () => {
    postToWorker({ type: 'mouseup' });
  });
  // (optional touch)
  window.addEventListener('touchstart', (e) => {
    const t = e.touches[0]; if(!t) return;
    postToWorker({ type:'mousemove', x: t.clientX, y: t.clientY });
    postToWorker({ type:'mousedown' });
  }, { passive:true });
  window.addEventListener('touchend', () => {
    postToWorker({ type:'mouseup' });
  });
  
  const initParamsObserver = new MutationObserver(() => { if (workerReady) { sendDistortParams(); initParamsObserver.disconnect(); }});
  initParamsObserver.observe(document.documentElement, { attributes:true });

  [$color, $alpha, $prob, $radius, $downMult, $fishEye].forEach(el => el.addEventListener('input', sendDistortParams));
  themeBtn.addEventListener('click', () => { setTimeout(sendDistortParams, 0); });
  
})();

/* ===== end ===== */
</script>
</body>
</html>
