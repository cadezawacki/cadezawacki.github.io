<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cade's Color Manager</title>
  <!-- Mobile & PWA Meta Tags -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#3498db">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <!-- Inline Manifest via Data URL (URL-encoded JSON) -->
  <link rel="manifest" href="data:application/manifest+json,%7B%22name%22%3A%22Cade%27s%20Color%20Manager%22%2C%22short_name%22%3A%22ColorMgr%22%2C%22start_url%22%3A%22.%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%23ffffff%22%2C%22theme_color%22%3A%22%233498db%22%7D">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
  <!-- Chroma.js for color math -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"></script>
  <style>
    /* Basic Reset & Styling */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family:"JetBrains Mono", serif; background: #f5f5f5; padding: 1rem; }
    .container {
      max-width: 1200px;
      margin: auto;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);

    }
    h1, h2, h3 { text-align: center; margin-bottom: 10px; }
    .section { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
    .input-group {
      margin-bottom: 10px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
    }
    .input-group label {
      flex: 0 0 120px;
      margin-right: 10px;
    }
    .input-group input {
      flex: 1 1 200px;
      padding: 5px;
      margin-right: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      transition: border 0.2s;
    }
    .input-group input.error { border: 1px solid red; }
    .input-group span.error-msg { color: red; font-size: 0.8rem; }
    button {
      padding: 8px 12px;
      margin: 5px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover { background: #ddd; }
    .color-picker { text-align: center; margin-bottom: 20px; }
    .color-picker input[type="color"] {
      width: 50px; height: 50px; border: none; cursor: pointer;
    }
    #gradientDisplay {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }
    .gradient-swatch {
      flex: 1;
      height: 50px;
      margin: 0 3px;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.15s, border 0.15s;
      border: 2px solid transparent;
    }
    .gradient-swatch:hover { transform: scale(1.05); border-color: #666; }
    .swatch-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    .swatch {
      width: 60px;
      height: 60px;
      margin: 5px;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: transform 0.15s, border 0.15s;
    }
    .swatch:hover { transform: scale(1.05); border-color: #666; }
    .preview { text-align: center; margin-top: 10px; }
    #previewButton {
      padding: 10px 20px;
      font-size: 1rem;
      border: none;
      border-radius: 4px;
      transition: background 0.3s, color 0.3s;
    }
    #contrastCheck { text-align: center; margin-top: 10px; font-size: 0.9rem; }
    /* History & Saved Palettes */
    .history-container, .saved-palettes {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
    }
    .history-swatch, .saved-swatch {
      width: 40px;
      height: 40px;
      margin: 5px;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: transform 0.15s, border 0.15s;
    }
    .history-swatch:hover, .saved-swatch:hover { transform: scale(1.1); border-color: #333; }
    /* 2D Grid */
    #gridDisplay {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 3px;
      margin-top: 10px;
      border: 2px solid black;
      padding: 1rem;
    }
    #gridDisplay>div{
      border-radius:8px;
    }
    #gridDisplay>div:hover{
      box-shadow: 1px 1px 4px 0px rgba(0, 0, 0, 0.4);
    }
    /* CSS Filter Generator Section */
    #cssFilterSection {
      text-align: center;
    }
    #luminanceConstrast>div {
      border: 1px solid black;
  }
  #lossString {
    font-weight: bold;
  }
  #loss-container {
    display: flex;
    flex-direction: row;
    align-items:center;
    justify-content: center;
    gap: 1rem;
    margin-top:0.5rem;
  }
  #filter-example-container  {
    display:flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width:100%;
  }

  #icon-container {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: 1rem;
  }
  #recomputeFilterBtn {
    width:fit-content;
  }
  #gradientSection>.input-group {
    display:flex;
    flex-direction:column;
    width:100%;
  }
  #gradientSection>.input-group label{
    flex:auto;
  }
  #gradientSection>.input-group input{
    flex:auto;
    width:100%;
  }
  #harmoniesSection {
      justify-items: center;
  }
  #vibeSelect {
      margin-bottom: 1rem;
  }
  #savedPalettesSection {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #pallete-container {
    display:flex;
    flex-direction: row;
    gap: 1rem;
  }
  #clearPaletteBtn {
    background-color:#b30000;
    color: white;
    font-weight: bold;
  }
  #color-picker-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  .copy-btn {
    padding:0px;
    margin:0px;
    background: transparent;
    border: none;
    cursor: pointer;
    font-size: 1.2em;
  }
  #sampleBlock {
    width:100%;
    height:3rem;
    margin-top:0px;
    padding-top:0px;
  }
  #colorPicker {
    width:300px;
    height:50px;
  }
  </style>
</head>
<body>
  <div class="container">
    <h1>Cade's Color Manager</h1>
    
    <!-- Color Inputs Section -->
    <div class="section" id="colorInputsSection">
      <h2>Color Inputs</h2>
      <div class="input-group">
        <label for="hexInput">Hex:</label>
        <input type="text" id="hexInput" placeholder="#RRGGBB">
        <button class="copy-btn" data-target="hexInput" title="Copy to clipboard"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="currentColor" d="M9 18q-.825 0-1.412-.587T7 16V4q0-.825.588-1.412T9 2h9q.825 0 1.413.588T20 4v12q0 .825-.587 1.413T18 18zm0-2h9V4H9zm-4 6q-.825 0-1.412-.587T3 20V6h2v14h11v2zm4-6V4z"/></svg></button>
        <span class="error-msg" id="hexError"></span>
      </div>
      <div class="input-group">
        <label for="rgbaInput">RGBA:</label>
        <input type="text" id="rgbaInput" placeholder="rgba(255,0,0,1)">
        <button class="copy-btn" data-target="rgbaInput" title="Copy to clipboard"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="currentColor" d="M9 18q-.825 0-1.412-.587T7 16V4q0-.825.588-1.412T9 2h9q.825 0 1.413.588T20 4v12q0 .825-.587 1.413T18 18zm0-2h9V4H9zm-4 6q-.825 0-1.412-.587T3 20V6h2v14h11v2zm4-6V4z"/></svg></button>
        <span class="error-msg" id="rgbaError"></span>
      </div>
      <div class="input-group">
        <label for="hslInput">HSL:</label>
        <input type="text" id="hslInput" placeholder="hsl(0,100%,50%)">
        <button class="copy-btn" data-target="hslInput" title="Copy to clipboard"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="currentColor" d="M9 18q-.825 0-1.412-.587T7 16V4q0-.825.588-1.412T9 2h9q.825 0 1.413.588T20 4v12q0 .825-.587 1.413T18 18zm0-2h9V4H9zm-4 6q-.825 0-1.412-.587T3 20V6h2v14h11v2zm4-6V4z"/></svg></button>
        <span class="error-msg" id="hslError"></span>
      </div>
      <div class="input-group">
        <label for="labInput">Lab:</label>
        <input type="text" id="labInput" placeholder="lab(53, 80, 67)">
        <button class="copy-btn" data-target="labInput" title="Copy to clipboard"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="currentColor" d="M9 18q-.825 0-1.412-.587T7 16V4q0-.825.588-1.412T9 2h9q.825 0 1.413.588T20 4v12q0 .825-.587 1.413T18 18zm0-2h9V4H9zm-4 6q-.825 0-1.412-.587T3 20V6h2v14h11v2zm4-6V4z"/></svg></button>
        <span class="error-msg" id="labError"></span>
      </div>
      <div class="input-group">
        <label for="cmykInput">CMYK:</label>
        <input type="text" id="cmykInput" placeholder="cmyk(0%, 50%, 50%, 0%)">
        <button class="copy-btn" data-target="cmykInput" title="Copy to clipboard"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="currentColor" d="M9 18q-.825 0-1.412-.587T7 16V4q0-.825.588-1.412T9 2h9q.825 0 1.413.588T20 4v12q0 .825-.587 1.413T18 18zm0-2h9V4H9zm-4 6q-.825 0-1.412-.587T3 20V6h2v14h11v2zm4-6V4z"/></svg></button>
        <span class="error-msg" id="cmykError"></span>
      </div>
      <div class="input-group">
        <label for="filterInput">CSS Filter:</label>
        <input type="text" id="filterInput" placeholder="invert(0%) hue-rotate(0deg)">
        <button class="copy-btn" data-target="filterInput" title="Copy to clipboard"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="currentColor" d="M9 18q-.825 0-1.412-.587T7 16V4q0-.825.588-1.412T9 2h9q.825 0 1.413.588T20 4v12q0 .825-.587 1.413T18 18zm0-2h9V4H9zm-4 6q-.825 0-1.412-.587T3 20V6h2v14h11v2zm4-6V4z"/></svg></button>
        <span class="error-msg" id="filterError"></span>
      </div>
    </div>

    <!-- Color Block -->
    <div class="section" id="colorBlockSection">
      <div id='color-picker-container'>
        <input type="color" id="colorPicker">
        <button id="eyeDropperBtn">Eye Dropper</button>
      </div>
    </div>

    <!-- CSS Filter Generator Section -->
    <div class="section" id="cssFilterSection">
      <h2>CSS Filter Generator</h2>
      <p>Target color: <span id="cssTargetColor"></span></p>
      <p>Computed Filter: <span id="computedFilter"></span></p>
      <div id="loss-container">
        <p id="filterLoss"></p>
        <p>⇒</p>
        <p id="lossString"></p>
      </div>
      <div id="filter-example-container">
        <div id="icon-container">
          <svg xmlns="http://www.w3.org/2000/svg" width="96" height="96" fill="#000000" viewBox="0 0 256 256"><path d="M224,64H154.67L126.93,43.2a16.12,16.12,0,0,0-9.6-3.2H72A16,16,0,0,0,56,56V72H40A16,16,0,0,0,24,88V200a16,16,0,0,0,16,16H192.89A15.13,15.13,0,0,0,208,200.89V184h16.89A15.13,15.13,0,0,0,240,168.89V80A16,16,0,0,0,224,64Zm0,104H208V112a16,16,0,0,0-16-16H122.67L94.93,75.2a16.12,16.12,0,0,0-9.6-3.2H72V56h45.33L147.2,78.4A8,8,0,0,0,152,80h72Z"></path></svg>
          <svg xmlns="http://www.w3.org/2000/svg" width="96" height="96" fill="#000000" viewBox="0 0 256 256"><path d="M80,192a8,8,0,0,1-8,8H32a8,8,0,0,1,0-16H72A8,8,0,0,1,80,192Zm144-8H184a8,8,0,0,0,0,16h40a8,8,0,0,0,0-16Zm-72,0H104a8,8,0,0,0,0,16h48a8,8,0,0,0,0-16ZM32,168h80a8,8,0,0,0,0-16H32a8,8,0,0,0,0,16Zm192-16H144a8,8,0,0,0,0,16h80a8,8,0,0,0,0-16Zm0-96H32a8,8,0,0,0-8,8V88a8,8,0,0,0,8,8H224a8,8,0,0,0,8-8V64A8,8,0,0,0,224,56Zm0,56H32a8,8,0,0,0-8,8v8a8,8,0,0,0,8,8H224a8,8,0,0,0,8-8v-8A8,8,0,0,0,224,112Z"></path></svg>
          <svg xmlns="http://www.w3.org/2000/svg" width="96" height="96" fill="#000000" viewBox="0 0 256 256"><path d="M254.88,195.92l-54.56-92.08A15.87,15.87,0,0,0,186.55,96h0a15.85,15.85,0,0,0-13.76,7.84l-15.64,26.39a4,4,0,0,0,0,4.07l26.8,45.47a8.13,8.13,0,0,1-1.89,10.55,8,8,0,0,1-11.8-2.26L101.79,71.88a16,16,0,0,0-27.58,0L1.11,195.94a8,8,0,0,0,1,9.52A8.23,8.23,0,0,0,8.23,208H247.77a8.29,8.29,0,0,0,6.09-2.55A8,8,0,0,0,254.88,195.92ZM64.43,120,88,80l23.57,40ZM140,52a24,24,0,1,1,24,24A24,24,0,0,1,140,52Z"></path></svg>
        </div>
        <button id="recomputeFilterBtn">Recompute Filter</button>
      </div>
    </div>
    
    <!-- Live Preview Section -->
    <div class="section" id="livePreviewSection">
      <h2>Live Preview</h2>
      <div class="preview">
        <button id="previewButton">Sample Button</button>
        <p style="margin-top:1rem"></p>
        <p id="previewText">This is sample text.</p>
        <p id="previewTextLighter" style="font-weight:lighter">This is sample light text.</p>
        <p id="previewTextBold" style="font-weight:bold">This is sample bold text.</p>
        <p style="margin-bottom:1rem"></p>
      </div>
      <div id="contrastCheck"></div>
    </div>

    <!-- Saved Palettes -->
    <div class="section" id="savedPalettesSection">
      <h2>Saved Palette</h2>
      <div id="pallete-container">
        <button id="savePaletteBtn">Save Current Color</button>
        <button id="clearPaletteBtn">Clear Pallete</button>
      </div>
      <div class="saved-palettes" id="savedPalettes"></div>
    </div>
    
    <!-- 1D Gradient Section (7 swatches) -->
    <div class="section" id="gradientSection">
      <h2>Gradient</h2>
      <div class="input-group" style="justify-content:center;">
        <label for="gradientSlider">Intensity:</label>
        <input type="range" id="gradientSlider" min="0" max="100" value="50">
      </div>
      <div id="gradientDisplay"></div>
    </div>
        
    <!-- Color Harmonies -->
    <div class="section" id="harmoniesSection">
      <h2>Color Harmonies</h2>

      <div id="vibe-container">
        <label>Adjust Colors by Vibe:</label>
        <select id="vibeSelect">
          <option value="default">None</option>
          <option value="pastel">Pastel</option>
          <option value="retro">Retro</option>
          <option value="cyberpunk">Cyberpunk</option>
          <option value="vintage">Vintage</option>
          <option value="vibrant">Vibrant</option>
          <option value="professional" selected>Professional</option>
          <option value="earthy">Earthy</option>
          <option value="neon">Neon</option>
          <option value="monochrome">Monochrome</option>
          <option value="warm">Warm</option>
          <option value="cool">Cool</option>
        </select>
      </div>

      <div id="harmonySimilar">
        <h3>Similar Colors</h3>
        <div class="swatch-container" id="similarColors"></div>
      </div>
      <div id="harmonyComplementary">
        <h3>Complementary Colors</h3>
        <div class="swatch-container" id="complementaryColors"></div>
      </div>
      <div id="harmonyAnalogous">
        <h3>Analogous Colors</h3>
        <div class="swatch-container" id="analogousColors"></div>
      </div>
      <div id="harmonyTriadic">
        <h3>Triadic Colors</h3>
        <div class="swatch-container" id="triadicColors"></div>
      </div>
      <div id="harmonyTetradic">
        <h3>Tetradic Colors</h3>
        <div class="swatch-container" id="tetradicColors"></div>
      </div>
      <div id="harmonySplit">
        <h3>Split‑Complementary</h3>
        <div class="swatch-container" id="splitColors"></div>
      </div>
      <div id="harmonyLuminance">
        <h3>Luminance Contrast</h3>
        <div class="swatch-container" id="luminanceConstrast"></div>
      </div>
    </div>
    
    <!-- 2D Gradient Grid Section -->
    <div class="section" id="gridGradientSection">
      <h2>2D Gradient Grid</h2>
      <div class="input-group" style="justify-content:center;">
        <label for="gridSatSlider">Saturation Variation:</label>
        <input type="range" id="gridSatSlider" min="0" max="100" value="50">
      </div>
      <div class="input-group" style="justify-content:center;">
        <label for="gridLightSlider">Lightness Variation:</label>
        <input type="range" id="gridLightSlider" min="0" max="100" value="30">
      </div>
      <div id="gridDisplay"></div>
    </div>
        
    <!-- History Section (moved to the bottom, limited to 10 entries) -->
    <div class="section" id="historySection" style="text-align:center;">
      <h2>History</h2>
      <button id="undoBtn">Undo</button>
      <button id="redoBtn">Redo</button>
      <div class="history-container" id="historyContainer"></div>
    </div>

    <!-- Set Background Color -->
    <div class="section" id="setBackground" style="text-align:center;">
      <h2>Set Background Color</h2>
      <button id="changeBackground">Change</button>
      <button id="resetBackground">Reset</button>
    </div>

    <div class="section" id="hotkeys" style="text-align:center;">
      <h2>Hot-Keys</h2>
      <p>Shift+B : Change the Background Color</p>
      <p>Shift+W : Reset the Background Color</p>
      <p>Shift+I : Inverts the whole page</p>
      <p>Shift+L : Inverts the whole page temporarily</p>
      <p>Shift+S : Save Current Color</p>
      <p>Ctrl+Z : Undo</p>
      <p>Ctrl+Y : Redo</p>
    </div>
    
  </div>
  
  <script>
    /***********************
     * Global Variables
     ***********************/
    let currentColor = chroma("#3498db");
    let updatingUI = false;
    let undoStack = [];
    let redoStack = [];
    let savedPalettes = [];
    let historyLimit = 100;
    
    /***********************
     * History & Saved Palettes
     ***********************/
    function setColor(newColor, pushHistory = true) {
      if (!newColor || !chroma.valid(newColor)) return;
      if (pushHistory) {
        undoStack.push(currentColor.hex());
        if (undoStack.length > historyLimit) { undoStack.shift(); }
        redoStack = [];
        updateHistoryUI();
      }
      currentColor = chroma(newColor);
      updateUI();
    }
    
    function updateHistoryUI() {
      const historyContainer = document.getElementById("historyContainer");
      historyContainer.innerHTML = "";
      // Display most recent history first
      undoStack.slice().reverse().forEach(colorHex => {
        const swatch = document.createElement("div");
        swatch.className = "history-swatch";
        swatch.style.backgroundColor = colorHex;
        swatch.addEventListener("click", () => setColor(colorHex));
        historyContainer.appendChild(swatch);
      });
    }
    
    function updateSavedPalettesUI() {
      const container = document.getElementById("savedPalettes");
      container.innerHTML = "";
      savedPalettes.forEach(colorHex => {
        const swatch = document.createElement("div");
        swatch.className = "saved-swatch";
        swatch.style.backgroundColor = colorHex;
        swatch.title = colorHex;
        swatch.addEventListener("click", () => setColor(colorHex));
        container.appendChild(swatch);
      });
    }
    
    /***********************
     * Live Preview & Contrast
     ***********************/
    function updateLivePreview() {
      const previewButton = document.getElementById("previewButton");
      const previewText = document.getElementById("previewText");
      const previewTextBold = document.getElementById("previewTextBold");
      const previewTextLighter = document.getElementById("previewTextLighter");
      const textColor = currentColor.luminance() < 0.5 ? "#fff" : "#000";
      previewButton.style.backgroundColor = currentColor.hex();
      previewButton.style.color = textColor;
      previewText.style.color = currentColor.hex();
      previewTextBold.style.color = currentColor.hex();
      previewTextLighter.style.color = currentColor.hex();
      const contrastWithWhite = chroma.contrast(currentColor, "white").toFixed(2);
      const contrastWithBlack = chroma.contrast(currentColor, "black").toFixed(2);
      document.getElementById("contrastCheck").innerText =
        "Contrast with white: " + contrastWithWhite +
        " | Contrast with black: " + contrastWithBlack;
    }
    
    /***********************
     * 1D Gradient (7 swatches)
     ***********************/
    function updateGradientDisplay() {
      const sliderVal = document.getElementById("gradientSlider").value;
      const intensity = sliderVal / 250; // roughly 0 to 0.4
      const baseHSL = currentColor.hsl();
      const clampL = (l) => Math.max(0, Math.min(1, l));
      let steps = [-3, -2, -1, 0, 1, 2, 3];
      let colors = steps.map(step =>
        chroma.hsl(baseHSL[0], baseHSL[1], clampL(baseHSL[2] + (step/3)*intensity))
      );
      const gradContainer = document.getElementById("gradientDisplay");
      gradContainer.innerHTML = "";
      colors.forEach(col => {
        const swatch = document.createElement("div");
        swatch.className = "gradient-swatch";
        swatch.style.backgroundColor = col.hex();
        swatch.addEventListener("click", () => setColor(col));
        gradContainer.appendChild(swatch);
      });
    }
    
    /***********************
     * 2D Gradient Grid
     ***********************/
    function updateGridDisplay() {
      const gridContainer = document.getElementById("gridDisplay");
      gridContainer.innerHTML = "";
      const gridSize = 5;
      const center = Math.floor(gridSize/2);
      const baseHSL = currentColor.hsl();
      const baseHue = baseHSL[0], baseSat = baseHSL[1], baseLight = baseHSL[2];
      let satVar = document.getElementById("gridSatSlider").value / 100 * 0.5; // 0 to 0.5
      let lightVar = document.getElementById("gridLightSlider").value / 100 * 0.5; // 0 to 0.5
      
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          let offsetX = col - center;
          let offsetY = row - center;
          let newSat = Math.min(1, Math.max(0, baseSat + offsetX * satVar));
          let newLight = Math.min(1, Math.max(0, baseLight + offsetY * lightVar));
          let newColor = chroma.hsl(baseHue, newSat, newLight);
          let cell = document.createElement("div");
          cell.style.backgroundColor = newColor.hex();
          cell.style.width = "100%";
          cell.style.paddingTop = "100%"; // square cell
          cell.style.position = "relative";
          cell.style.cursor = "pointer";
          cell.title = newColor.hex();
          cell.addEventListener("click", () => setColor(newColor));
          let inner = document.createElement("div");
          inner.style.position = "absolute";
          inner.style.top = "0";
          inner.style.bottom = "0";
          inner.style.left = "0";
          inner.style.right = "0";
          cell.appendChild(inner);
          gridContainer.appendChild(cell);
        }
      }
    }
    
    /***********************
     * Color Harmonies & Vibe Adjustments
     ***********************/
    function updateHarmonies() {
      const vibe = document.getElementById("vibeSelect").value;
      // Clear harmony containers
      ["similarColors", "complementaryColors", "analogousColors",
       "triadicColors", "tetradicColors", "splitColors", "luminanceConstrast"].forEach(id => {
         document.getElementById(id).innerHTML = "";
      });
      const baseHSL = currentColor.hsl();
      
      // Similar Colors (using more offsets)
      const similarOffsets = [-30, -20, -10, 10, 20, 30];
      similarOffsets.forEach(off => {
        let col = chroma.hsl((baseHSL[0] + off + 360) % 360, baseHSL[1], baseHSL[2]);
        col = adjustForVibe(col, vibe);
        addSwatch(col, document.getElementById("similarColors"));
      });
      
      // Complementary Colors (base and two offsets)
      let comp = getComplement(currentColor);
      comp = adjustForVibe(comp, vibe);
      addSwatch(comp, document.getElementById("complementaryColors"));
      let compPlus = chroma.hsl((comp.hsl()[0] + 10) % 360, comp.hsl()[1], comp.hsl()[2]);
      let compMinus = chroma.hsl((comp.hsl()[0] - 10 + 360) % 360, comp.hsl()[1], comp.hsl()[2]);
      compPlus = adjustForVibe(compPlus, vibe);
      compMinus = adjustForVibe(compMinus, vibe);
      addSwatch(compPlus, document.getElementById("complementaryColors"));
      addSwatch(compMinus, document.getElementById("complementaryColors"));
      
      // Analogous (±30°)
      let ana1 = chroma.hsl((baseHSL[0] + 30) % 360, baseHSL[1], baseHSL[2]);
      let ana2 = chroma.hsl((baseHSL[0] - 30 + 360) % 360, baseHSL[1], baseHSL[2]);
      ana1 = adjustForVibe(ana1, vibe);
      ana2 = adjustForVibe(ana2, vibe);
      addSwatch(ana1, document.getElementById("analogousColors"));
      addSwatch(ana2, document.getElementById("analogousColors"));
      
      // Triadic (±120°)
      let tri1 = chroma.hsl((baseHSL[0] + 120) % 360, baseHSL[1], baseHSL[2]);
      let tri2 = chroma.hsl((baseHSL[0] + 240) % 360, baseHSL[1], baseHSL[2]);
      tri1 = adjustForVibe(tri1, vibe);
      tri2 = adjustForVibe(tri2, vibe);
      addSwatch(tri1, document.getElementById("triadicColors"));
      addSwatch(tri2, document.getElementById("triadicColors"));
      
      // Tetradic (square: 90° offsets)
      let tet1 = chroma.hsl((baseHSL[0] + 90) % 360, baseHSL[1], baseHSL[2]);
      let tet2 = chroma.hsl((baseHSL[0] + 180) % 360, baseHSL[1], baseHSL[2]);
      let tet3 = chroma.hsl((baseHSL[0] + 270) % 360, baseHSL[1], baseHSL[2]);
      tet1 = adjustForVibe(tet1, vibe);
      tet2 = adjustForVibe(tet2, vibe);
      tet3 = adjustForVibe(tet3, vibe);
      addSwatch(tet1, document.getElementById("tetradicColors"));
      addSwatch(tet2, document.getElementById("tetradicColors"));
      addSwatch(tet3, document.getElementById("tetradicColors"));
      
      // Split‑Complementary (complement ±30°)
      let split1 = chroma.hsl((baseHSL[0] + 180 - 30 + 360) % 360, baseHSL[1], baseHSL[2]);
      let split2 = chroma.hsl((baseHSL[0] + 180 + 30) % 360, baseHSL[1], baseHSL[2]);
      split1 = adjustForVibe(split1, vibe);
      split2 = adjustForVibe(split2, vibe);
      addSwatch(split1, document.getElementById("splitColors"));
      addSwatch(split2, document.getElementById("splitColors"));

      // High-contrast: choose black or white depending on luminance.
      let contrast = currentColor.luminance() > 0.5 ? chroma("black") : chroma("white");
      addSwatch(contrast, document.getElementById("luminanceConstrast"));

    }
    
    // Helper: add a swatch element to a container
    function addSwatch(color, container) {
      const swatch = document.createElement("div");
      swatch.className = "swatch";
      swatch.style.backgroundColor = color.hex();
      swatch.title = color.hex();
      swatch.addEventListener("click", () => setColor(color));
      container.appendChild(swatch);
    }
    
    // Get the complementary color (hue + 180°)
    function getComplement(color) {
      let hsl = color.hsl();
      hsl[0] = (hsl[0] + 180) % 360;
      return chroma.hsl(hsl[0], hsl[1], hsl[2]);
    }
    
    // Adjust a color based on a selected vibe preset
    function adjustForVibe(color, vibe) {
      let hsl = color.hsl();
      switch(vibe) {
        case "pastel":
          return chroma.hsl(hsl[0], hsl[1] * 0.5, Math.min(hsl[2] + 0.15, 1));
        case "retro":
          return chroma.hsl(hsl[0], hsl[1] * 0.8, hsl[2] * 0.9);
        case "cyberpunk":
          return chroma.hsl(hsl[0], Math.min(hsl[1] * 1.3, 1), Math.min(hsl[2] + 0.1, 1));
        case "vintage":
          return chroma.hsl((hsl[0] + 10) % 360, hsl[1] * 0.7, hsl[2]);
        case "vibrant":
          return chroma.hsl(hsl[0], Math.min(hsl[1] * 1.5, 1), hsl[2]);
        case "professional":
          return chroma.hsl(hsl[0], hsl[1] * 0.85, hsl[2]);
        case "earthy":
          return chroma.hsl((hsl[0] - 20 + 360) % 360, Math.max(hsl[1] - 0.2, 0), hsl[2]);
        case "neon":
          return chroma.hsl(hsl[0], 1, Math.min(hsl[2] + 0.2, 1));
        case "monochrome":
          return chroma.hsl(hsl[0], 0, hsl[2]);
        case "warm":
          return chroma.hsl((hsl[0] + 10) % 360, hsl[1], hsl[2]);
        case "cool":
          return chroma.hsl((hsl[0] - 10 + 360) % 360, hsl[1], hsl[2]);
        default:
          return color;
      }
    }
    
    /***********************
     * CMYK Conversions
     ***********************/
    function rgbToCmyk(r, g, b) {
      let rP = r / 255, gP = g / 255, bP = b / 255;
      let k = 1 - Math.max(rP, gP, bP);
      let c = (1 - rP - k) / (1 - k) || 0;
      let m = (1 - gP - k) / (1 - k) || 0;
      let y = (1 - bP - k) / (1 - k) || 0;
      return [c, m, y, k];
    }
    
    function cmykToRgb(c, m, y, k) {
      let r = 255 * (1 - c) * (1 - k);
      let g = 255 * (1 - m) * (1 - k);
      let b = 255 * (1 - y) * (1 - k);
      return [r, g, b];
    }
    
    /***********************
     * Update All UI Fields
     ***********************/
    function updateUI() {
      updatingUI = true;
      // Update color picker
      document.getElementById("colorPicker").value = currentColor.hex();
      
      // Hex
      document.getElementById("hexInput").value = currentColor.hex();
      document.getElementById("hexInput").classList.remove("error");
      document.getElementById("hexError").innerText = "";
      
      // RGBA
      let rgba = currentColor.rgba();
      document.getElementById("rgbaInput").value = `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${parseFloat(rgba[3].toFixed(2))})`;
      document.getElementById("rgbaInput").classList.remove("error");
      document.getElementById("rgbaError").innerText = "";
      
      // HSL
      let hsl = currentColor.hsl();
      document.getElementById("hslInput").value = `hsl(${Math.round(hsl[0])}, ${Math.round(hsl[1]*100)}%, ${Math.round(hsl[2]*100)}%)`;
      document.getElementById("hslInput").classList.remove("error");
      document.getElementById("hslError").innerText = "";
      
      // Lab
      let lab = currentColor.lab();
      document.getElementById("labInput").value = `lab(${lab[0].toFixed(1)}, ${lab[1].toFixed(1)}, ${lab[2].toFixed(1)})`;
      document.getElementById("labInput").classList.remove("error");
      document.getElementById("labError").innerText = "";
      
      // CMYK
      let rgb = currentColor.rgb();
      let cmyk = rgbToCmyk(rgb[0], rgb[1], rgb[2]);
      let cmykPercent = cmyk.map(v => Math.round(v * 100));
      document.getElementById("cmykInput").value = `cmyk(${cmykPercent[0]}%, ${cmykPercent[1]}%, ${cmykPercent[2]}%, ${cmykPercent[3]}%)`;
      document.getElementById("cmykInput").classList.remove("error");
      document.getElementById("cmykError").innerText = "";
      
      // CSS Filter input will be updated by updateCssFilter()
      document.getElementById("filterInput").classList.remove("error");
      document.getElementById("filterError").innerText = "";
      
      // Update Live Preview, Gradient, Harmonies, 2D Grid, and CSS Filter Generator
      updateLivePreview();
      updateGradientDisplay();
      updateHarmonies();
      updateGridDisplay();
      updateCssFilter();
      
      updatingUI = false;
    }
    
    // A simple CSS Filter conversion (our original simplified version for the input field)
    function colorToFilter(color) {
      let lum = color.luminance();
      let inv = ((1 - lum) * 100).toFixed(0);
      return `invert(${inv}%) hue-rotate(0deg)`;
    }
    
    // Parse a simplified CSS filter string back to a color
    function filterToColor(filterStr) {
      const invMatch = filterStr.match(/invert\(\s*(\d+)%\s*\)/);
      const hueMatch = filterStr.match(/hue-rotate\(\s*(\d+)deg\s*\)/);
      let invFactor = invMatch ? parseInt(invMatch[1], 10) / 100 : 0;
      let hueAdj = hueMatch ? parseInt(hueMatch[1], 10) : 0;
      let comp = getComplement(currentColor);
      let newColor = chroma.mix(currentColor, comp, invFactor, 'rgb');
      let hsl = newColor.hsl();
      hsl[0] = (hsl[0] + hueAdj) % 360;
      return chroma.hsl(hsl[0], hsl[1], hsl[2]);
    }
    
    /***********************
     * Parsing & Validation for Inputs
     ***********************/
    function parseHex(val) {
      if (!/^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$/.test(val.trim()))
        return parseQuickHex(val);
      return chroma(val.trim());
    }

    function parseQuickHex(val) {
      if (!/([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$/.test(val.trim()))
        throw new Error("Invalid hex format");
      return chroma("#" + val.trim());
    }
    
    function parseRGBA(val) {
      let m = val.match(/rgba?\s*\(\s*(\d+)[,\s]+(\d+)[,\s]+(\d+)(?:[,\s]+([\d.]+))?\s*\)/);
      if (!m) throw new Error("Invalid RGBA format");
      let r = parseInt(m[1], 10),
          g = parseInt(m[2], 10),
          b = parseInt(m[3], 10),
          a = m[4] !== undefined ? parseFloat(m[4]) : 1;
      return chroma(r, g, b, a);
    }
    
    function parseHSL(val) {
      let m = val.match(/hsl\s*\(\s*(\d+)[,\s]+(\d+)%[,\s]+(\d+)%\s*\)/);
      if (!m) throw new Error("Invalid HSL format");
      let h = parseInt(m[1], 10),
          s = parseInt(m[2], 10) / 100,
          l = parseInt(m[3], 10) / 100;
      return chroma.hsl(h, s, l);
    }
    
    function parseLab(val) {
      let m = val.match(/lab\s*\(\s*([\d.]+)[,\s]+([-]?[\d.]+)[,\s]+([-]?[\d.]+)\s*\)/);
      if (!m) throw new Error("Invalid Lab format");
      let L = parseFloat(m[1]),
          a = parseFloat(m[2]),
          b = parseFloat(m[3]);
      return chroma.lab(L, a, b);
    }
    
    function parseCMYK(val) {
      let m = val.match(/cmyk\s*\(\s*([\d.]+)%?\s*,\s*([\d.]+)%?\s*,\s*([\d.]+)%?\s*,\s*([\d.]+)%?\s*\)/);
      if (!m) throw new Error("Invalid CMYK format");
      let c = parseFloat(m[1]),
          mC = parseFloat(m[2]),
          y = parseFloat(m[3]),
          k = parseFloat(m[4]);
      if (c > 1 || mC > 1 || y > 1 || k > 1) {
        c /= 100; mC /= 100; y /= 100; k /= 100;
      }
      let rgbArr = cmykToRgb(c, mC, y, k);
      return chroma(rgbArr);
    }
    
    function parseFilter(val) {
      return filterToColor(val);
    }

    function debounce(func, wait) {
      let timeout;
      return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }
    
    document.getElementById("hexInput").addEventListener("input", debounce((e) => {
      if(updatingUI) return;
      try {
        let col = parseHex(e.target.value);
        setColor(col);
      } catch (err) {
        e.target.classList.add("error");
        document.getElementById("hexError").innerText = err.message;
      }
    }, 500));

    document.getElementById("rgbaInput").addEventListener("input", debounce((e) => {
      if (updatingUI) return;
      try {
        let col = parseRGBA(e.target.value);
        setColor(col);
      } catch (err) {
        e.target.classList.add("error");
        document.getElementById("rgbaError").innerText = err.message;
      }
    }, 500));
    
    document.getElementById("hslInput").addEventListener("input", debounce((e) => {
      if (updatingUI) return;
      try {
        let col = parseHSL(e.target.value);
        setColor(col);
      } catch (err) {
        e.target.classList.add("error");
        document.getElementById("hslError").innerText = err.message;
      }
    }, 500));
    
    document.getElementById("labInput").addEventListener("input", debounce((e) => {
      if (updatingUI) return;
      try {
        let col = parseLab(e.target.value);
        setColor(col);
      } catch (err) {
        e.target.classList.add("error");
        document.getElementById("labError").innerText = err.message;
      }
    }, 500));
    
    document.getElementById("cmykInput").addEventListener("input", debounce((e) => {
      if (updatingUI) return;
      try {
        let col = parseCMYK(e.target.value);
        setColor(col);
      } catch (err) {
        e.target.classList.add("error");
        document.getElementById("cmykError").innerText = err.message;
      }
    }, 500));
    
    document.getElementById("filterInput").addEventListener("input", debounce((e) => {
      if (updatingUI) return;
      try {
        let col = parseFilter(e.target.value);
        setColor(col);
      } catch (err) {
        e.target.classList.add("error");
        document.getElementById("filterError").innerText = err.message;
      }
    }, 500));
    
    document.getElementById("colorPicker").addEventListener("input", debounce((e) => {
      if (updatingUI) return;
      setColor(e.target.value);
    }, 500));
    
    document.getElementById("eyeDropperBtn").addEventListener("click", async () => {
      if (window.EyeDropper) {
        try {
          const eye = new EyeDropper();
          const result = await eye.open();
          setColor(result.sRGBHex);
        } catch (err) {
          alert("EyeDropper error: " + err);
        }
      } else {
        alert("EyeDropper API not supported in this browser.");
      }
    });
    
    document.getElementById("gradientSlider").addEventListener("input", updateGradientDisplay);
    document.getElementById("vibeSelect").addEventListener("change", updateHarmonies);
    document.getElementById("gridSatSlider").addEventListener("input", updateGridDisplay);
    document.getElementById("gridLightSlider").addEventListener("input", updateGridDisplay);
    
    function undo(){
      if (undoStack.length > 0) {
        redoStack.push(currentColor.hex());
        let prevColor = undoStack.pop();
        setColor(prevColor, false);
        updateHistoryUI();
      }
    }

    function redo(){
      if (redoStack.length > 0) {
        undoStack.push(currentColor.hex());
        if (undoStack.length > 10) { undoStack.shift(); }
        let nextColor = redoStack.pop();
        setColor(nextColor, false);
        updateHistoryUI();
      }
    }

    document.getElementById("undoBtn").addEventListener("click", () => {
      undo()
    });
    
    document.getElementById("redoBtn").addEventListener("click", () => {
      redo()
    });
    
    document.getElementById("savePaletteBtn").addEventListener("click", () => {
      savedPalettes.push(currentColor.hex());
      updateSavedPalettesUI();
    });

    
    document.getElementById("clearPaletteBtn").addEventListener("click", () => {
      savedPalettes = [];
      updateSavedPalettesUI();
    });

    function changeBackgroundColor(){
      document.querySelector(".container").style.backgroundColor = currentColor.hex();
    }

    function resetBackgroundColor(){
      document.querySelector(".container").style.backgroundColor = "#fff"
    }

    document.getElementById("changeBackground").addEventListener("click", () => {
      changeBackgroundColor()
    });

    document.getElementById("resetBackground").addEventListener("click", () => {
      resetBackgroundColor()
    });

    document.addEventListener('keydown', (e) => {
      if (e.shiftKey && e.code == 'KeyL') {
        document.querySelector(".container").style.filter = "invert(1)"
      } else if (e.shiftKey && e.code == 'KeyI') {
        if (document.querySelector(".container").style.filter === "invert(1)") {
          document.querySelector(".container").style.filter = "invert(0)"
        } else {
          document.querySelector(".container").style.filter = "invert(1)"
        }
      } else if (e.shiftKey && e.code == 'KeyB') {
        changeBackgroundColor()
      } else if (e.shiftKey && e.code == 'KeyW') {
        resetBackgroundColor()
      } else if (e.ctrlKey && e.code == 'KeyZ') {
        undo()
      } else if (e.ctrlKey && e.code == 'KeyY') {
        redo()
      } else if (e.shiftKey && e.code == 'KeyS') {
          savedPalettes.push(currentColor.hex());
          updateSavedPalettesUI();
      } else if (e.shiftKey && e.code == 'KeyC') {
          navigator.clipboard.writeText(currentColor.hex())
      }
    }, false);

    document.addEventListener('keyup', (e) => {
      if (e.shiftKey && e.code == 'KeyL') {
        document.querySelector(".container").style.filter = "invert(0)"
      }
    }, false);

    document.querySelectorAll('.copy-btn').forEach(button => {
      button.addEventListener('click', () => {
        const targetId = button.getAttribute('data-target');
        const inputElem = document.getElementById(targetId);
        if (inputElem) {
          navigator.clipboard.writeText(inputElem.value).then(() => {
            button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="currentColor" d="m9.55 18l-5.7-5.7l1.425-1.425L9.55 15.15l9.175-9.175L20.15 7.4z"/></svg>';
            setTimeout(() => {
              button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="currentColor" d="M9 18q-.825 0-1.412-.587T7 16V4q0-.825.588-1.412T9 2h9q.825 0 1.413.588T20 4v12q0 .825-.587 1.413T18 18zm0-2h9V4H9zm-4 6q-.825 0-1.412-.587T3 20V6h2v14h11v2zm4-6V4z"/></svg>`;
            }, 1000);
          }).catch(err => {
            console.error('Copy failed:', err);
          });
        }
      });
    });

    
    
    // New: CSS Filter Generator functions
    function applyFilterToBlack(params) {
      // Start with black [0,0,0]. Then simulate the filter chain.
      let inv = params.invert / 100;
      // invert: mix black and white (if invert is 100, result is white)
      let r = (1 - inv) * 0 + inv * 255;
      let g = (1 - inv) * 0 + inv * 255;
      let b = (1 - inv) * 0 + inv * 255;
      // sepia: apply a simple sepia transformation
      let s = params.sepia / 100;
      let rSep = r * (1 - s) + (r * 0.393 + g * 0.769 + b * 0.189) * s;
      let gSep = g * (1 - s) + (r * 0.349 + g * 0.686 + b * 0.168) * s;
      let bSep = b * (1 - s) + (r * 0.272 + g * 0.534 + b * 0.131) * s;
      r = rSep; g = gSep; b = bSep;
      // saturate: adjust saturation via HSL
      let col = chroma([r, g, b]);
      let hsl = col.hsl();
      let satFactor = params.saturate / 100; // 100 means no change
      hsl[1] = hsl[1] * satFactor;
      col = chroma.hsl(hsl[0], hsl[1], hsl[2]);
      [r, g, b] = col.rgb();
      // hue-rotate: add hue rotation (in degrees)
      col = chroma([r, g, b]);
      hsl = col.hsl();
      hsl[0] = (hsl[0] + params.hueRotate) % 360;
      col = chroma.hsl(hsl[0], hsl[1], hsl[2]);
      [r, g, b] = col.rgb();
      // brightness: multiply each channel
      let bright = params.brightness / 100;
      r *= bright; g *= bright; b *= bright;
      // contrast: adjust contrast using a simple formula
      let contrast = params.contrast / 100;
      r = 128 + contrast * (r - 128);
      g = 128 + contrast * (g - 128);
      b = 128 + contrast * (b - 128);
      // Clamp channels to [0,255]
      r = Math.max(0, Math.min(255, r));
      g = Math.max(0, Math.min(255, g));
      b = Math.max(0, Math.min(255, b));
      return [r, g, b];
    }
    
    function solveCssFilter(targetHex) {
      let targetColor = chroma(targetHex);
      let best = { 
        params: { invert: 100, sepia: 0, saturate: 100, hueRotate: 0, brightness: 100, contrast: 100 }, 
        loss: Infinity 
      };
      // Random search initial phase
      for (let i = 0; i < 1000; i++) {
        let candidate = {
          invert: Math.random() * 100,
          sepia: Math.random() * 100,
          saturate: 100 + Math.random() * 500,
          hueRotate: Math.random() * 360,
          brightness: 50 + Math.random() * 150,
          contrast: 50 + Math.random() * 150
        };
        let result = applyFilterToBlack(candidate);
        let candidateColor = chroma.rgb(result);
        let loss = chroma.deltaE(candidateColor, targetColor);
        if (loss < best.loss) {
          best = { params: candidate, loss: loss };
        }
      }
      // Local refinement phase
      for (let i = 0; i < 1000; i++) {
        let candidate = {
          invert: best.params.invert + (Math.random() - 0.5) * 10,
          sepia: best.params.sepia + (Math.random() - 0.5) * 10,
          saturate: best.params.saturate + (Math.random() - 0.5) * 50,
          hueRotate: best.params.hueRotate + (Math.random() - 0.5) * 20,
          brightness: best.params.brightness + (Math.random() - 0.5) * 20,
          contrast: best.params.contrast + (Math.random() - 0.5) * 20
        };
        candidate.invert = Math.max(0, Math.min(100, candidate.invert));
        candidate.sepia = Math.max(0, Math.min(100, candidate.sepia));
        candidate.saturate = Math.max(0, candidate.saturate);
        candidate.hueRotate = ((candidate.hueRotate % 360) + 360) % 360;
        candidate.brightness = Math.max(0, candidate.brightness);
        candidate.contrast = Math.max(0, candidate.contrast);
        let result = applyFilterToBlack(candidate);
        let candidateColor = chroma.rgb(result);
        let loss = chroma.deltaE(candidateColor, targetColor);
        if (loss < best.loss) {
          best = { params: candidate, loss: loss };
        }
      }
      return best;
    }
    
    function cssFilterString(params) {
      return `invert(${params.invert.toFixed(0)}%) sepia(${params.sepia.toFixed(0)}%) saturate(${params.saturate.toFixed(0)}%) hue-rotate(${params.hueRotate.toFixed(0)}deg) brightness(${params.brightness.toFixed(0)}%) contrast(${params.contrast.toFixed(0)}%)`;
    }
    
    function updateCssFilter() {
      let result = solveCssFilter(currentColor.hex());
      let filterStr = cssFilterString(result.params);
      document.getElementById("computedFilter").innerText = filterStr;
      document.getElementById("cssTargetColor").innerText = currentColor.hex();
      document.getElementById("filterLoss").innerText = "Loss: " + result.loss.toFixed(2);

      // String to evaluate loss
      let lossStr;
      if (result.loss < 1) {
        lossStr = "Probably good.";
      } else if (result.loss < 5) {
        lossStr = "Meh.";
      } else if (result.loss < 15) {
        lossStr = "Not great. Likely want to re-run.";
      } else {
        lossStr = "Yikes. Extremely off, please recompute."
      }
      
      document.getElementById("lossString").innerText = lossStr;

      // Update Filter for Svgs
      Array.from(document.querySelectorAll("#icon-container>svg")).forEach((e) => e.style.filter = filterStr);

      // Link computed filter value to the CSS Filter input box
      document.getElementById("filterInput").value = filterStr;
    }
    
    document.getElementById("recomputeFilterBtn").addEventListener("click", updateCssFilter);
    
    /***********************
     * Initialize UI on load
     ***********************/
    updateUI();
    
    /***********************
     * Service Worker Registration (PWA)
     ***********************/
    if ('serviceWorker' in navigator) {
      const swCode = `
        const CACHE_NAME = 'color-manager-cache-v1';
        const urlsToCache = [location.href];
        self.addEventListener('install', event => {
          event.waitUntil(
            caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))
          );
        });
        self.addEventListener('fetch', event => {
          event.respondWith(
            caches.match(event.request).then(response => response || fetch(event.request))
          );
        });
      `;
      const blob = new Blob([swCode], { type: 'text/javascript' });
      const swUrl = URL.createObjectURL(blob);
      navigator.serviceWorker.register(swUrl)
        .then(registration => {
          console.log('Service worker registered:', registration);
        })
        .catch(error => {
          console.error('Service worker registration failed:', error);
        });
    }
  </script>
</body>
</html>
